// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PREFABCOMPONENT_HDN_H_
#define FLATBUFFERS_GENERATED_PREFABCOMPONENT_HDN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "core_generated.h"

namespace hdn {

struct TransformComponent;
struct TransformComponentBuilder;

struct ModelComponent;
struct ModelComponentBuilder;

struct LightComponent;
struct LightComponentBuilder;

struct ScriptComponent;
struct ScriptComponentBuilder;

struct HierarchyComponent;
struct HierarchyComponentBuilder;

struct Component;
struct ComponentBuilder;

enum ComponentType : int8_t {
  ComponentType_NONE = 0,
  ComponentType_TRANSFORM = 1,
  ComponentType_MODEL = 2,
  ComponentType_LIGHT = 3,
  ComponentType_SCRIPT = 4,
  ComponentType_HIERARCHY = 5,
  ComponentType_MIN = ComponentType_NONE,
  ComponentType_MAX = ComponentType_HIERARCHY
};

inline const ComponentType (&EnumValuesComponentType())[6] {
  static const ComponentType values[] = {
    ComponentType_NONE,
    ComponentType_TRANSFORM,
    ComponentType_MODEL,
    ComponentType_LIGHT,
    ComponentType_SCRIPT,
    ComponentType_HIERARCHY
  };
  return values;
}

inline const char * const *EnumNamesComponentType() {
  static const char * const names[7] = {
    "NONE",
    "TRANSFORM",
    "MODEL",
    "LIGHT",
    "SCRIPT",
    "HIERARCHY",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponentType(ComponentType e) {
  if (::flatbuffers::IsOutRange(e, ComponentType_NONE, ComponentType_HIERARCHY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComponentType()[index];
}

enum ComponentUnion : uint8_t {
  ComponentUnion_NONE = 0,
  ComponentUnion_TransformComponent = 1,
  ComponentUnion_ModelComponent = 2,
  ComponentUnion_LightComponent = 3,
  ComponentUnion_ScriptComponent = 4,
  ComponentUnion_MIN = ComponentUnion_NONE,
  ComponentUnion_MAX = ComponentUnion_ScriptComponent
};

inline const ComponentUnion (&EnumValuesComponentUnion())[5] {
  static const ComponentUnion values[] = {
    ComponentUnion_NONE,
    ComponentUnion_TransformComponent,
    ComponentUnion_ModelComponent,
    ComponentUnion_LightComponent,
    ComponentUnion_ScriptComponent
  };
  return values;
}

inline const char * const *EnumNamesComponentUnion() {
  static const char * const names[6] = {
    "NONE",
    "TransformComponent",
    "ModelComponent",
    "LightComponent",
    "ScriptComponent",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponentUnion(ComponentUnion e) {
  if (::flatbuffers::IsOutRange(e, ComponentUnion_NONE, ComponentUnion_ScriptComponent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComponentUnion()[index];
}

template<typename T> struct ComponentUnionTraits {
  static const ComponentUnion enum_value = ComponentUnion_NONE;
};

template<> struct ComponentUnionTraits<hdn::TransformComponent> {
  static const ComponentUnion enum_value = ComponentUnion_TransformComponent;
};

template<> struct ComponentUnionTraits<hdn::ModelComponent> {
  static const ComponentUnion enum_value = ComponentUnion_ModelComponent;
};

template<> struct ComponentUnionTraits<hdn::LightComponent> {
  static const ComponentUnion enum_value = ComponentUnion_LightComponent;
};

template<> struct ComponentUnionTraits<hdn::ScriptComponent> {
  static const ComponentUnion enum_value = ComponentUnion_ScriptComponent;
};

bool VerifyComponentUnion(::flatbuffers::Verifier &verifier, const void *obj, ComponentUnion type);
bool VerifyComponentUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct TransformComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_ROTATION = 6,
    VT_SCALE = 8
  };
  const hdn::Vec3 *position() const {
    return GetPointer<const hdn::Vec3 *>(VT_POSITION);
  }
  const hdn::Vec4 *rotation() const {
    return GetPointer<const hdn::Vec4 *>(VT_ROTATION);
  }
  const hdn::Vec3 *scale() const {
    return GetPointer<const hdn::Vec3 *>(VT_SCALE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyTable(rotation()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyTable(scale()) &&
           verifier.EndTable();
  }
};

struct TransformComponentBuilder {
  typedef TransformComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(::flatbuffers::Offset<hdn::Vec3> position) {
    fbb_.AddOffset(TransformComponent::VT_POSITION, position);
  }
  void add_rotation(::flatbuffers::Offset<hdn::Vec4> rotation) {
    fbb_.AddOffset(TransformComponent::VT_ROTATION, rotation);
  }
  void add_scale(::flatbuffers::Offset<hdn::Vec3> scale) {
    fbb_.AddOffset(TransformComponent::VT_SCALE, scale);
  }
  explicit TransformComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransformComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransformComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransformComponent> CreateTransformComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<hdn::Vec3> position = 0,
    ::flatbuffers::Offset<hdn::Vec4> rotation = 0,
    ::flatbuffers::Offset<hdn::Vec3> scale = 0) {
  TransformComponentBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  return builder_.Finish();
}

struct ModelComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESH = 4,
    VT_MATERIAL = 6
  };
  const ::flatbuffers::String *mesh() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESH);
  }
  const ::flatbuffers::String *material() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESH) &&
           verifier.VerifyString(mesh()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           verifier.EndTable();
  }
};

struct ModelComponentBuilder {
  typedef ModelComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mesh(::flatbuffers::Offset<::flatbuffers::String> mesh) {
    fbb_.AddOffset(ModelComponent::VT_MESH, mesh);
  }
  void add_material(::flatbuffers::Offset<::flatbuffers::String> material) {
    fbb_.AddOffset(ModelComponent::VT_MATERIAL, material);
  }
  explicit ModelComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelComponent> CreateModelComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mesh = 0,
    ::flatbuffers::Offset<::flatbuffers::String> material = 0) {
  ModelComponentBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_mesh(mesh);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelComponent> CreateModelComponentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mesh = nullptr,
    const char *material = nullptr) {
  auto mesh__ = mesh ? _fbb.CreateString(mesh) : 0;
  auto material__ = material ? _fbb.CreateString(material) : 0;
  return hdn::CreateModelComponent(
      _fbb,
      mesh__,
      material__);
}

struct LightComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LightComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_INTENSITY = 6
  };
  const hdn::Vec3 *color() const {
    return GetPointer<const hdn::Vec3 *>(VT_COLOR);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyField<float>(verifier, VT_INTENSITY, 4) &&
           verifier.EndTable();
  }
};

struct LightComponentBuilder {
  typedef LightComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<hdn::Vec3> color) {
    fbb_.AddOffset(LightComponent::VT_COLOR, color);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(LightComponent::VT_INTENSITY, intensity, 0.0f);
  }
  explicit LightComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LightComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LightComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LightComponent> CreateLightComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<hdn::Vec3> color = 0,
    float intensity = 0.0f) {
  LightComponentBuilder builder_(_fbb);
  builder_.add_intensity(intensity);
  builder_.add_color(color);
  return builder_.Finish();
}

struct ScriptComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScriptComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASS_NAME = 4,
    VT_PARAMETERS = 6
  };
  const ::flatbuffers::String *class_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASS_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<hdn::KeyValue>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<hdn::KeyValue>> *>(VT_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           verifier.EndTable();
  }
};

struct ScriptComponentBuilder {
  typedef ScriptComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_class_name(::flatbuffers::Offset<::flatbuffers::String> class_name) {
    fbb_.AddOffset(ScriptComponent::VT_CLASS_NAME, class_name);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<hdn::KeyValue>>> parameters) {
    fbb_.AddOffset(ScriptComponent::VT_PARAMETERS, parameters);
  }
  explicit ScriptComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScriptComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScriptComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScriptComponent> CreateScriptComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> class_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<hdn::KeyValue>>> parameters = 0) {
  ScriptComponentBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_class_name(class_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ScriptComponent> CreateScriptComponentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *class_name = nullptr,
    const std::vector<::flatbuffers::Offset<hdn::KeyValue>> *parameters = nullptr) {
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<hdn::KeyValue>>(*parameters) : 0;
  return hdn::CreateScriptComponent(
      _fbb,
      class_name__,
      parameters__);
}

struct HierarchyComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HierarchyComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHILDREN = 4
  };
  const ::flatbuffers::Vector<const hdn::uuid *> *children() const {
    return GetPointer<const ::flatbuffers::Vector<const hdn::uuid *> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.EndTable();
  }
};

struct HierarchyComponentBuilder {
  typedef HierarchyComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<const hdn::uuid *>> children) {
    fbb_.AddOffset(HierarchyComponent::VT_CHILDREN, children);
  }
  explicit HierarchyComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HierarchyComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HierarchyComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HierarchyComponent> CreateHierarchyComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const hdn::uuid *>> children = 0) {
  HierarchyComponentBuilder builder_(_fbb);
  builder_.add_children(children);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HierarchyComponent> CreateHierarchyComponentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<hdn::uuid> *children = nullptr) {
  auto children__ = children ? _fbb.CreateVectorOfStructs<hdn::uuid>(*children) : 0;
  return hdn::CreateHierarchyComponent(
      _fbb,
      children__);
}

struct Component FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  hdn::ComponentType type() const {
    return static_cast<hdn::ComponentType>(GetField<int8_t>(VT_TYPE, 0));
  }
  hdn::ComponentUnion data_type() const {
    return static_cast<hdn::ComponentUnion>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const hdn::TransformComponent *data_as_TransformComponent() const {
    return data_type() == hdn::ComponentUnion_TransformComponent ? static_cast<const hdn::TransformComponent *>(data()) : nullptr;
  }
  const hdn::ModelComponent *data_as_ModelComponent() const {
    return data_type() == hdn::ComponentUnion_ModelComponent ? static_cast<const hdn::ModelComponent *>(data()) : nullptr;
  }
  const hdn::LightComponent *data_as_LightComponent() const {
    return data_type() == hdn::ComponentUnion_LightComponent ? static_cast<const hdn::LightComponent *>(data()) : nullptr;
  }
  const hdn::ScriptComponent *data_as_ScriptComponent() const {
    return data_type() == hdn::ComponentUnion_ScriptComponent ? static_cast<const hdn::ScriptComponent *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyComponentUnion(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const hdn::TransformComponent *Component::data_as<hdn::TransformComponent>() const {
  return data_as_TransformComponent();
}

template<> inline const hdn::ModelComponent *Component::data_as<hdn::ModelComponent>() const {
  return data_as_ModelComponent();
}

template<> inline const hdn::LightComponent *Component::data_as<hdn::LightComponent>() const {
  return data_as_LightComponent();
}

template<> inline const hdn::ScriptComponent *Component::data_as<hdn::ScriptComponent>() const {
  return data_as_ScriptComponent();
}

struct ComponentBuilder {
  typedef Component Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(hdn::ComponentType type) {
    fbb_.AddElement<int8_t>(Component::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(hdn::ComponentUnion data_type) {
    fbb_.AddElement<uint8_t>(Component::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Component::VT_DATA, data);
  }
  explicit ComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Component> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Component>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Component> CreateComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    hdn::ComponentType type = hdn::ComponentType_NONE,
    hdn::ComponentUnion data_type = hdn::ComponentUnion_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  ComponentBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline bool VerifyComponentUnion(::flatbuffers::Verifier &verifier, const void *obj, ComponentUnion type) {
  switch (type) {
    case ComponentUnion_NONE: {
      return true;
    }
    case ComponentUnion_TransformComponent: {
      auto ptr = reinterpret_cast<const hdn::TransformComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentUnion_ModelComponent: {
      auto ptr = reinterpret_cast<const hdn::ModelComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentUnion_LightComponent: {
      auto ptr = reinterpret_cast<const hdn::LightComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentUnion_ScriptComponent: {
      auto ptr = reinterpret_cast<const hdn::ScriptComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyComponentUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyComponentUnion(
        verifier,  values->Get(i), types->GetEnum<ComponentUnion>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace hdn

#endif  // FLATBUFFERS_GENERATED_PREFABCOMPONENT_HDN_H_
