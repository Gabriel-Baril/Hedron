// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PREFABCOMPONENT_DM_H_
#define FLATBUFFERS_GENERATED_PREFABCOMPONENT_DM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
									FLATBUFFERS_VERSION_MINOR == 12 &&
									FLATBUFFERS_VERSION_REVISION == 23,
							"Non-compatible flatbuffers version included");

#include "core_generated.h"

namespace dm
{

	struct CTransformComponent;
	struct CTransformComponentBuilder;

	struct CModelComponent;
	struct CModelComponentBuilder;

	struct CLightComponent;
	struct CLightComponentBuilder;

	struct CScriptComponent;
	struct CScriptComponentBuilder;

	struct CHierarchyComponent;
	struct CHierarchyComponentBuilder;

	struct CComponent;
	struct CComponentBuilder;

	enum CComponentType : int8_t
	{
		CComponentType_NONE = 0,
		CComponentType_TRANSFORM = 1,
		CComponentType_MODEL = 2,
		CComponentType_LIGHT = 3,
		CComponentType_SCRIPT = 4,
		CComponentType_HIERARCHY = 5,
		CComponentType_MIN = CComponentType_NONE,
		CComponentType_MAX = CComponentType_HIERARCHY
	};

	inline const CComponentType (&EnumValuesCComponentType())[6]
	{
		static const CComponentType values[] = {
				CComponentType_NONE,
				CComponentType_TRANSFORM,
				CComponentType_MODEL,
				CComponentType_LIGHT,
				CComponentType_SCRIPT,
				CComponentType_HIERARCHY};
		return values;
	}

	inline const char *const *EnumNamesCComponentType()
	{
		static const char *const names[7] = {
				"NONE",
				"TRANSFORM",
				"MODEL",
				"LIGHT",
				"SCRIPT",
				"HIERARCHY",
				nullptr};
		return names;
	}

	inline const char *EnumNameCComponentType(CComponentType e)
	{
		if (::flatbuffers::IsOutRange(e, CComponentType_NONE, CComponentType_HIERARCHY))
			return "";
		const size_t index = static_cast<size_t>(e);
		return EnumNamesCComponentType()[index];
	}

	enum CComponentUnion : uint8_t
	{
		CComponentUnion_NONE = 0,
		CComponentUnion_CTransformComponent = 1,
		CComponentUnion_CModelComponent = 2,
		CComponentUnion_CLightComponent = 3,
		CComponentUnion_CScriptComponent = 4,
		CComponentUnion_MIN = CComponentUnion_NONE,
		CComponentUnion_MAX = CComponentUnion_CScriptComponent
	};

	inline const CComponentUnion (&EnumValuesCComponentUnion())[5]
	{
		static const CComponentUnion values[] = {
				CComponentUnion_NONE,
				CComponentUnion_CTransformComponent,
				CComponentUnion_CModelComponent,
				CComponentUnion_CLightComponent,
				CComponentUnion_CScriptComponent};
		return values;
	}

	inline const char *const *EnumNamesCComponentUnion()
	{
		static const char *const names[6] = {
				"NONE",
				"CTransformComponent",
				"CModelComponent",
				"CLightComponent",
				"CScriptComponent",
				nullptr};
		return names;
	}

	inline const char *EnumNameCComponentUnion(CComponentUnion e)
	{
		if (::flatbuffers::IsOutRange(e, CComponentUnion_NONE, CComponentUnion_CScriptComponent))
			return "";
		const size_t index = static_cast<size_t>(e);
		return EnumNamesCComponentUnion()[index];
	}

	template <typename T>
	struct CComponentUnionTraits
	{
		static const CComponentUnion enum_value = CComponentUnion_NONE;
	};

	template <>
	struct CComponentUnionTraits<dm::CTransformComponent>
	{
		static const CComponentUnion enum_value = CComponentUnion_CTransformComponent;
	};

	template <>
	struct CComponentUnionTraits<dm::CModelComponent>
	{
		static const CComponentUnion enum_value = CComponentUnion_CModelComponent;
	};

	template <>
	struct CComponentUnionTraits<dm::CLightComponent>
	{
		static const CComponentUnion enum_value = CComponentUnion_CLightComponent;
	};

	template <>
	struct CComponentUnionTraits<dm::CScriptComponent>
	{
		static const CComponentUnion enum_value = CComponentUnion_CScriptComponent;
	};

	bool VerifyCComponentUnion(::flatbuffers::Verifier &verifier, const void *obj, CComponentUnion type);
	bool VerifyCComponentUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

	struct CTransformComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CTransformComponentBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_POSITION = 4,
			VT_ROTATION = 6,
			VT_SCALE = 8
		};
		const dm::CVec3 *position() const
		{
			return GetPointer<const dm::CVec3 *>(VT_POSITION);
		}
		const dm::CVec4 *rotation() const
		{
			return GetPointer<const dm::CVec4 *>(VT_ROTATION);
		}
		const dm::CVec3 *scale() const
		{
			return GetPointer<const dm::CVec3 *>(VT_SCALE);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyOffset(verifier, VT_POSITION) &&
						 verifier.VerifyTable(position()) &&
						 VerifyOffset(verifier, VT_ROTATION) &&
						 verifier.VerifyTable(rotation()) &&
						 VerifyOffset(verifier, VT_SCALE) &&
						 verifier.VerifyTable(scale()) &&
						 verifier.EndTable();
		}
	};

	struct CTransformComponentBuilder
	{
		typedef CTransformComponent Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_position(::flatbuffers::Offset<dm::CVec3> position)
		{
			fbb_.AddOffset(CTransformComponent::VT_POSITION, position);
		}
		void add_rotation(::flatbuffers::Offset<dm::CVec4> rotation)
		{
			fbb_.AddOffset(CTransformComponent::VT_ROTATION, rotation);
		}
		void add_scale(::flatbuffers::Offset<dm::CVec3> scale)
		{
			fbb_.AddOffset(CTransformComponent::VT_SCALE, scale);
		}
		explicit CTransformComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CTransformComponent> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CTransformComponent>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CTransformComponent> CreateCTransformComponent(
			::flatbuffers::FlatBufferBuilder &_fbb,
			::flatbuffers::Offset<dm::CVec3> position = 0,
			::flatbuffers::Offset<dm::CVec4> rotation = 0,
			::flatbuffers::Offset<dm::CVec3> scale = 0)
	{
		CTransformComponentBuilder builder_(_fbb);
		builder_.add_scale(scale);
		builder_.add_rotation(rotation);
		builder_.add_position(position);
		return builder_.Finish();
	}

	struct CModelComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CModelComponentBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_MESH = 4,
			VT_MATERIAL = 6
		};
		const ::flatbuffers::String *mesh() const
		{
			return GetPointer<const ::flatbuffers::String *>(VT_MESH);
		}
		const ::flatbuffers::String *material() const
		{
			return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyOffset(verifier, VT_MESH) &&
						 verifier.VerifyString(mesh()) &&
						 VerifyOffset(verifier, VT_MATERIAL) &&
						 verifier.VerifyString(material()) &&
						 verifier.EndTable();
		}
	};

	struct CModelComponentBuilder
	{
		typedef CModelComponent Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_mesh(::flatbuffers::Offset<::flatbuffers::String> mesh)
		{
			fbb_.AddOffset(CModelComponent::VT_MESH, mesh);
		}
		void add_material(::flatbuffers::Offset<::flatbuffers::String> material)
		{
			fbb_.AddOffset(CModelComponent::VT_MATERIAL, material);
		}
		explicit CModelComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CModelComponent> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CModelComponent>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CModelComponent> CreateCModelComponent(
			::flatbuffers::FlatBufferBuilder &_fbb,
			::flatbuffers::Offset<::flatbuffers::String> mesh = 0,
			::flatbuffers::Offset<::flatbuffers::String> material = 0)
	{
		CModelComponentBuilder builder_(_fbb);
		builder_.add_material(material);
		builder_.add_mesh(mesh);
		return builder_.Finish();
	}

	inline ::flatbuffers::Offset<CModelComponent> CreateCModelComponentDirect(
			::flatbuffers::FlatBufferBuilder &_fbb,
			const char *mesh = nullptr,
			const char *material = nullptr)
	{
		auto mesh__ = mesh ? _fbb.CreateString(mesh) : 0;
		auto material__ = material ? _fbb.CreateString(material) : 0;
		return dm::CreateCModelComponent(
				_fbb,
				mesh__,
				material__);
	}

	struct CLightComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CLightComponentBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_COLOR = 4,
			VT_INTENSITY = 6
		};
		const dm::CVec3 *color() const
		{
			return GetPointer<const dm::CVec3 *>(VT_COLOR);
		}
		float intensity() const
		{
			return GetField<float>(VT_INTENSITY, 0.0f);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyOffset(verifier, VT_COLOR) &&
						 verifier.VerifyTable(color()) &&
						 VerifyField<float>(verifier, VT_INTENSITY, 4) &&
						 verifier.EndTable();
		}
	};

	struct CLightComponentBuilder
	{
		typedef CLightComponent Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_color(::flatbuffers::Offset<dm::CVec3> color)
		{
			fbb_.AddOffset(CLightComponent::VT_COLOR, color);
		}
		void add_intensity(float intensity)
		{
			fbb_.AddElement<float>(CLightComponent::VT_INTENSITY, intensity, 0.0f);
		}
		explicit CLightComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CLightComponent> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CLightComponent>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CLightComponent> CreateCLightComponent(
			::flatbuffers::FlatBufferBuilder &_fbb,
			::flatbuffers::Offset<dm::CVec3> color = 0,
			float intensity = 0.0f)
	{
		CLightComponentBuilder builder_(_fbb);
		builder_.add_intensity(intensity);
		builder_.add_color(color);
		return builder_.Finish();
	}

	struct CScriptComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CScriptComponentBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_CLASS_NAME = 4,
			VT_PARAMETERS = 6
		};
		const ::flatbuffers::String *class_name() const
		{
			return GetPointer<const ::flatbuffers::String *>(VT_CLASS_NAME);
		}
		const ::flatbuffers::Vector<::flatbuffers::Offset<dm::CKeyValue>> *parameters() const
		{
			return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dm::CKeyValue>> *>(VT_PARAMETERS);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyOffset(verifier, VT_CLASS_NAME) &&
						 verifier.VerifyString(class_name()) &&
						 VerifyOffset(verifier, VT_PARAMETERS) &&
						 verifier.VerifyVector(parameters()) &&
						 verifier.VerifyVectorOfTables(parameters()) &&
						 verifier.EndTable();
		}
	};

	struct CScriptComponentBuilder
	{
		typedef CScriptComponent Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_class_name(::flatbuffers::Offset<::flatbuffers::String> class_name)
		{
			fbb_.AddOffset(CScriptComponent::VT_CLASS_NAME, class_name);
		}
		void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dm::CKeyValue>>> parameters)
		{
			fbb_.AddOffset(CScriptComponent::VT_PARAMETERS, parameters);
		}
		explicit CScriptComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CScriptComponent> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CScriptComponent>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CScriptComponent> CreateCScriptComponent(
			::flatbuffers::FlatBufferBuilder &_fbb,
			::flatbuffers::Offset<::flatbuffers::String> class_name = 0,
			::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dm::CKeyValue>>> parameters = 0)
	{
		CScriptComponentBuilder builder_(_fbb);
		builder_.add_parameters(parameters);
		builder_.add_class_name(class_name);
		return builder_.Finish();
	}

	inline ::flatbuffers::Offset<CScriptComponent> CreateCScriptComponentDirect(
			::flatbuffers::FlatBufferBuilder &_fbb,
			const char *class_name = nullptr,
			const std::vector<::flatbuffers::Offset<dm::CKeyValue>> *parameters = nullptr)
	{
		auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
		auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<dm::CKeyValue>>(*parameters) : 0;
		return dm::CreateCScriptComponent(
				_fbb,
				class_name__,
				parameters__);
	}

	struct CHierarchyComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CHierarchyComponentBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_CHILDREN = 4
		};
		const ::flatbuffers::Vector<const dm::CUUID *> *children() const
		{
			return GetPointer<const ::flatbuffers::Vector<const dm::CUUID *> *>(VT_CHILDREN);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyOffset(verifier, VT_CHILDREN) &&
						 verifier.VerifyVector(children()) &&
						 verifier.EndTable();
		}
	};

	struct CHierarchyComponentBuilder
	{
		typedef CHierarchyComponent Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_children(::flatbuffers::Offset<::flatbuffers::Vector<const dm::CUUID *>> children)
		{
			fbb_.AddOffset(CHierarchyComponent::VT_CHILDREN, children);
		}
		explicit CHierarchyComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CHierarchyComponent> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CHierarchyComponent>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CHierarchyComponent> CreateCHierarchyComponent(
			::flatbuffers::FlatBufferBuilder &_fbb,
			::flatbuffers::Offset<::flatbuffers::Vector<const dm::CUUID *>> children = 0)
	{
		CHierarchyComponentBuilder builder_(_fbb);
		builder_.add_children(children);
		return builder_.Finish();
	}

	inline ::flatbuffers::Offset<CHierarchyComponent> CreateCHierarchyComponentDirect(
			::flatbuffers::FlatBufferBuilder &_fbb,
			const std::vector<dm::CUUID> *children = nullptr)
	{
		auto children__ = children ? _fbb.CreateVectorOfStructs<dm::CUUID>(*children) : 0;
		return dm::CreateCHierarchyComponent(
				_fbb,
				children__);
	}

	struct CComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CComponentBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_TYPE = 4,
			VT_DATA_TYPE = 6,
			VT_DATA = 8
		};
		dm::CComponentType type() const
		{
			return static_cast<dm::CComponentType>(GetField<int8_t>(VT_TYPE, 0));
		}
		dm::CComponentUnion data_type() const
		{
			return static_cast<dm::CComponentUnion>(GetField<uint8_t>(VT_DATA_TYPE, 0));
		}
		const void *data() const
		{
			return GetPointer<const void *>(VT_DATA);
		}
		template <typename T>
		const T *data_as() const;
		const dm::CTransformComponent *data_as_CTransformComponent() const
		{
			return data_type() == dm::CComponentUnion_CTransformComponent ? static_cast<const dm::CTransformComponent *>(data()) : nullptr;
		}
		const dm::CModelComponent *data_as_CModelComponent() const
		{
			return data_type() == dm::CComponentUnion_CModelComponent ? static_cast<const dm::CModelComponent *>(data()) : nullptr;
		}
		const dm::CLightComponent *data_as_CLightComponent() const
		{
			return data_type() == dm::CComponentUnion_CLightComponent ? static_cast<const dm::CLightComponent *>(data()) : nullptr;
		}
		const dm::CScriptComponent *data_as_CScriptComponent() const
		{
			return data_type() == dm::CComponentUnion_CScriptComponent ? static_cast<const dm::CScriptComponent *>(data()) : nullptr;
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
						 VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
						 VerifyOffset(verifier, VT_DATA) &&
						 VerifyCComponentUnion(verifier, data(), data_type()) &&
						 verifier.EndTable();
		}
	};

	template <>
	inline const dm::CTransformComponent *CComponent::data_as<dm::CTransformComponent>() const
	{
		return data_as_CTransformComponent();
	}

	template <>
	inline const dm::CModelComponent *CComponent::data_as<dm::CModelComponent>() const
	{
		return data_as_CModelComponent();
	}

	template <>
	inline const dm::CLightComponent *CComponent::data_as<dm::CLightComponent>() const
	{
		return data_as_CLightComponent();
	}

	template <>
	inline const dm::CScriptComponent *CComponent::data_as<dm::CScriptComponent>() const
	{
		return data_as_CScriptComponent();
	}

	struct CComponentBuilder
	{
		typedef CComponent Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_type(dm::CComponentType type)
		{
			fbb_.AddElement<int8_t>(CComponent::VT_TYPE, static_cast<int8_t>(type), 0);
		}
		void add_data_type(dm::CComponentUnion data_type)
		{
			fbb_.AddElement<uint8_t>(CComponent::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
		}
		void add_data(::flatbuffers::Offset<void> data)
		{
			fbb_.AddOffset(CComponent::VT_DATA, data);
		}
		explicit CComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CComponent> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CComponent>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CComponent> CreateCComponent(
			::flatbuffers::FlatBufferBuilder &_fbb,
			dm::CComponentType type = dm::CComponentType_NONE,
			dm::CComponentUnion data_type = dm::CComponentUnion_NONE,
			::flatbuffers::Offset<void> data = 0)
	{
		CComponentBuilder builder_(_fbb);
		builder_.add_data(data);
		builder_.add_data_type(data_type);
		builder_.add_type(type);
		return builder_.Finish();
	}

	inline bool VerifyCComponentUnion(::flatbuffers::Verifier &verifier, const void *obj, CComponentUnion type)
	{
		switch (type)
		{
		case CComponentUnion_NONE:
		{
			return true;
		}
		case CComponentUnion_CTransformComponent:
		{
			auto ptr = reinterpret_cast<const dm::CTransformComponent *>(obj);
			return verifier.VerifyTable(ptr);
		}
		case CComponentUnion_CModelComponent:
		{
			auto ptr = reinterpret_cast<const dm::CModelComponent *>(obj);
			return verifier.VerifyTable(ptr);
		}
		case CComponentUnion_CLightComponent:
		{
			auto ptr = reinterpret_cast<const dm::CLightComponent *>(obj);
			return verifier.VerifyTable(ptr);
		}
		case CComponentUnion_CScriptComponent:
		{
			auto ptr = reinterpret_cast<const dm::CScriptComponent *>(obj);
			return verifier.VerifyTable(ptr);
		}
		default:
			return true;
		}
	}

	inline bool VerifyCComponentUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types)
	{
		if (!values || !types)
			return !values && !types;
		if (values->size() != types->size())
			return false;
		for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
		{
			if (!VerifyCComponentUnion(
							verifier, values->Get(i), types->GetEnum<CComponentUnion>(i)))
			{
				return false;
			}
		}
		return true;
	}

} // namespace dm

#endif // FLATBUFFERS_GENERATED_PREFABCOMPONENT_DM_H_
