// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CORE_DM_H_
#define FLATBUFFERS_GENERATED_CORE_DM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
									FLATBUFFERS_VERSION_MINOR == 12 &&
									FLATBUFFERS_VERSION_REVISION == 23,
							"Non-compatible flatbuffers version included");

namespace dm
{

	struct CKeyValue;
	struct CKeyValueBuilder;

	struct CVec3;
	struct CVec3Builder;

	struct CVec4;
	struct CVec4Builder;

	struct CUUID;

	enum CAssetType : uint32_t
	{
		CAssetType_buildconfig = 0,
		CAssetType_feature = 1,
		CAssetType_prefab = 2,
		CAssetType_variant = 3,
		CAssetType_zonealias = 4,
		CAssetType_MIN = CAssetType_buildconfig,
		CAssetType_MAX = CAssetType_zonealias
	};

	inline const CAssetType (&EnumValuesCAssetType())[5]
	{
		static const CAssetType values[] = {
				CAssetType_buildconfig,
				CAssetType_feature,
				CAssetType_prefab,
				CAssetType_variant,
				CAssetType_zonealias};
		return values;
	}

	inline const char *const *EnumNamesCAssetType()
	{
		static const char *const names[6] = {
				"buildconfig",
				"feature",
				"prefab",
				"variant",
				"zonealias",
				nullptr};
		return names;
	}

	inline const char *EnumNameCAssetType(CAssetType e)
	{
		if (::flatbuffers::IsOutRange(e, CAssetType_buildconfig, CAssetType_zonealias))
			return "";
		const size_t index = static_cast<size_t>(e);
		return EnumNamesCAssetType()[index];
	}

	FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8)
	CUUID FLATBUFFERS_FINAL_CLASS
	{
	private:
		uint64_t low_;
		uint64_t high_;

	public:
		CUUID()
				: low_(0),
					high_(0)
		{
		}
		CUUID(uint64_t _low, uint64_t _high)
				: low_(::flatbuffers::EndianScalar(_low)),
					high_(::flatbuffers::EndianScalar(_high))
		{
		}
		uint64_t low() const
		{
			return ::flatbuffers::EndianScalar(low_);
		}
		uint64_t high() const
		{
			return ::flatbuffers::EndianScalar(high_);
		}
	};
	FLATBUFFERS_STRUCT_END(CUUID, 16);

	struct CKeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CKeyValueBuilder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_KEY = 4,
			VT_VALUE = 6
		};
		const ::flatbuffers::String *key() const
		{
			return GetPointer<const ::flatbuffers::String *>(VT_KEY);
		}
		const ::flatbuffers::String *value() const
		{
			return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyOffset(verifier, VT_KEY) &&
						 verifier.VerifyString(key()) &&
						 VerifyOffset(verifier, VT_VALUE) &&
						 verifier.VerifyString(value()) &&
						 verifier.EndTable();
		}
	};

	struct CKeyValueBuilder
	{
		typedef CKeyValue Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_key(::flatbuffers::Offset<::flatbuffers::String> key)
		{
			fbb_.AddOffset(CKeyValue::VT_KEY, key);
		}
		void add_value(::flatbuffers::Offset<::flatbuffers::String> value)
		{
			fbb_.AddOffset(CKeyValue::VT_VALUE, value);
		}
		explicit CKeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CKeyValue> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CKeyValue>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CKeyValue> CreateCKeyValue(
			::flatbuffers::FlatBufferBuilder &_fbb,
			::flatbuffers::Offset<::flatbuffers::String> key = 0,
			::flatbuffers::Offset<::flatbuffers::String> value = 0)
	{
		CKeyValueBuilder builder_(_fbb);
		builder_.add_value(value);
		builder_.add_key(key);
		return builder_.Finish();
	}

	inline ::flatbuffers::Offset<CKeyValue> CreateCKeyValueDirect(
			::flatbuffers::FlatBufferBuilder &_fbb,
			const char *key = nullptr,
			const char *value = nullptr)
	{
		auto key__ = key ? _fbb.CreateString(key) : 0;
		auto value__ = value ? _fbb.CreateString(value) : 0;
		return dm::CreateCKeyValue(
				_fbb,
				key__,
				value__);
	}

	struct CVec3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CVec3Builder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_X = 4,
			VT_Y = 6,
			VT_Z = 8
		};
		float x() const
		{
			return GetField<float>(VT_X, 0.0f);
		}
		float y() const
		{
			return GetField<float>(VT_Y, 0.0f);
		}
		float z() const
		{
			return GetField<float>(VT_Z, 0.0f);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyField<float>(verifier, VT_X, 4) &&
						 VerifyField<float>(verifier, VT_Y, 4) &&
						 VerifyField<float>(verifier, VT_Z, 4) &&
						 verifier.EndTable();
		}
	};

	struct CVec3Builder
	{
		typedef CVec3 Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_x(float x)
		{
			fbb_.AddElement<float>(CVec3::VT_X, x, 0.0f);
		}
		void add_y(float y)
		{
			fbb_.AddElement<float>(CVec3::VT_Y, y, 0.0f);
		}
		void add_z(float z)
		{
			fbb_.AddElement<float>(CVec3::VT_Z, z, 0.0f);
		}
		explicit CVec3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CVec3> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CVec3>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CVec3> CreateCVec3(
			::flatbuffers::FlatBufferBuilder &_fbb,
			float x = 0.0f,
			float y = 0.0f,
			float z = 0.0f)
	{
		CVec3Builder builder_(_fbb);
		builder_.add_z(z);
		builder_.add_y(y);
		builder_.add_x(x);
		return builder_.Finish();
	}

	struct CVec4 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
	{
		typedef CVec4Builder Builder;
		enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
		{
			VT_X = 4,
			VT_Y = 6,
			VT_Z = 8,
			VT_W = 10
		};
		float x() const
		{
			return GetField<float>(VT_X, 0.0f);
		}
		float y() const
		{
			return GetField<float>(VT_Y, 0.0f);
		}
		float z() const
		{
			return GetField<float>(VT_Z, 0.0f);
		}
		float w() const
		{
			return GetField<float>(VT_W, 0.0f);
		}
		bool Verify(::flatbuffers::Verifier &verifier) const
		{
			return VerifyTableStart(verifier) &&
						 VerifyField<float>(verifier, VT_X, 4) &&
						 VerifyField<float>(verifier, VT_Y, 4) &&
						 VerifyField<float>(verifier, VT_Z, 4) &&
						 VerifyField<float>(verifier, VT_W, 4) &&
						 verifier.EndTable();
		}
	};

	struct CVec4Builder
	{
		typedef CVec4 Table;
		::flatbuffers::FlatBufferBuilder &fbb_;
		::flatbuffers::uoffset_t start_;
		void add_x(float x)
		{
			fbb_.AddElement<float>(CVec4::VT_X, x, 0.0f);
		}
		void add_y(float y)
		{
			fbb_.AddElement<float>(CVec4::VT_Y, y, 0.0f);
		}
		void add_z(float z)
		{
			fbb_.AddElement<float>(CVec4::VT_Z, z, 0.0f);
		}
		void add_w(float w)
		{
			fbb_.AddElement<float>(CVec4::VT_W, w, 0.0f);
		}
		explicit CVec4Builder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb)
		{
			start_ = fbb_.StartTable();
		}
		::flatbuffers::Offset<CVec4> Finish()
		{
			const auto end = fbb_.EndTable(start_);
			auto o = ::flatbuffers::Offset<CVec4>(end);
			return o;
		}
	};

	inline ::flatbuffers::Offset<CVec4> CreateCVec4(
			::flatbuffers::FlatBufferBuilder &_fbb,
			float x = 0.0f,
			float y = 0.0f,
			float z = 0.0f,
			float w = 0.0f)
	{
		CVec4Builder builder_(_fbb);
		builder_.add_w(w);
		builder_.add_z(z);
		builder_.add_y(y);
		builder_.add_x(x);
		return builder_.Finish();
	}

} // namespace dm

#endif // FLATBUFFERS_GENERATED_CORE_DM_H_
